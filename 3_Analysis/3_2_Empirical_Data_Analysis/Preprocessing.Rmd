---
title: "Untitled"
author: "why"
date: "2025-11-15"
output: html_document
---

```{r}
# 预处理是将RAWDATA1和Complains_YoungClients（即未经处理的医生原始数据）进行处理的代码，处理规则如下：
# 在本研究的数据预处理中，Rawdata1.xlsx 与 Complains_YoungClients.xls 两个数据表均包含重复的 ID。
# 为了确保后续分析中每个 ID 仅保留一条最合适的记录，我们制定并实施了如下匹配与筛选规则：
# 1. 两个数据表均出现的 ID（共同 ID）
# 当某个 ID 同时存在于 Rawdata1 与 Complains 数据表中，且各自都可能有多条记录时：
# 规则：找到 Raw 中每条记录与 Complains 中每条记录之间的时间差，保留时间差最小的那一对。
# Raw 表使用字段：提交时间（parsed datetime）
# Complains 表使用字段：就诊日期（parsed datetime）
# 对所有组合计算时间差（绝对值，单位秒）选择时间差最小的一对 仅保留这一行 Raw 及这一行 Complains 其余记录全部删除
# 这样保证共同 ID 在两个文件中都仅保留 最匹配的、最接近的时间点。
# 2. 仅在 Rawdata1 中出现的 ID
# 当某个 ID 出现在 Rawdata1 中，但不出现在 Complains 中时：
# 规则：保留 Rawdata1 中该 ID 的所有记录里 “提交时间最早” 的一条。
# 同时删除该 ID 的其他记录
# 这样保证 Raw 中的独有 ID 也只保留一条最合理的数据。
# 3. 仅在 Complains_YoungClients 中出现的 ID
# 当某个 ID 出现在 Complains 中，但 不出现在 Rawdata1 中时：
# 规则：保留 Complains 中该 ID 的所有记录里 “就诊日期最早” 的一条。
# 同时删除该 ID 的其他记录
# 这保证 Complains 中的独有 ID 也只保留一条最代表性的记录。
# 输出数据文件为：Raw_output.xlsx 也是后续检出率和EGA载入的数据文件。
library(readxl)
library(dplyr)
library(lubridate)
library(here)
library(openxlsx)

#==========================================================
# 1. 读取数据
#==========================================================
raw <- read_excel(here("DATA", "Rawdata1.xlsx"))
cmp <- read_excel(here("DATA", "Complains_YoungClients.xls"))

# 强制 ID 字段为字符
raw$ID <- as.character(raw$ID)
cmp$门诊ID <- as.character(cmp$门诊ID)

#==========================================================
# 2. 解析 Raw 的提交时间（英文格式 + 数字格式）
#==========================================================

# 去掉 " CST"
raw$提交时间_clean <- gsub(" CST", "", raw$提交时间, fixed = TRUE)

# 创建解析结果列
raw$提交时间_parsed <- NA

# --- 英文格式 (例: Wed May 25 14:04:35 2022) ---
idx_eng <- grepl("[A-Za-z]{3} [A-Za-z]{3} [0-9]{1,2}", raw$提交时间_clean)

old_locale <- Sys.getlocale("LC_TIME")
Sys.setlocale("LC_TIME", "C")   # 切到英文环境，识别 Wed / May

raw$提交时间_parsed[idx_eng] <- as.POSIXct(
  raw$提交时间_clean[idx_eng],
  format = "%a %b %d %H:%M:%S %Y",
  tz = "Asia/Shanghai"
)

Sys.setlocale("LC_TIME", old_locale)  # 解析完恢复

# --- 数字格式 (例: 2023-06-17 10:11:28) ---
idx_num <- grepl("^\\d{4}-\\d{2}-\\d{2}", raw$提交时间_clean)

raw$提交时间_parsed[idx_num] <- as.POSIXct(
  raw$提交时间_clean[idx_num],
  format = "%Y-%m-%d %H:%M:%S",
  tz = "Asia/Shanghai"
)

#==========================================================
# 3. 解析 Complains 的就诊日期
#==========================================================
cmp$就诊日期_parsed <- as.POSIXct(
  cmp$就诊日期,
  format = "%Y/%m/%d %H:%M:%S",
  tz = "Asia/Shanghai"
)

#==========================================================
# 4. ID 分类
#==========================================================
common_ids <- intersect(raw$ID, cmp$门诊ID)
only_raw_ids <- setdiff(raw$ID, cmp$门诊ID)
only_cmp_ids <- setdiff(cmp$门诊ID, raw$ID)

#==========================================================
# 5. 共同 ID —— Raw & Complains 时间最接近的一对
#==========================================================
matched_pairs <- raw %>%
  filter(ID %in% common_ids) %>%
  left_join(cmp, by = c("ID" = "门诊ID")) %>%
  mutate(
    time_diff = abs(as.numeric(
      difftime(提交时间_parsed, 就诊日期_parsed, units = "secs")
    )),
    time_diff = ifelse(is.na(time_diff), Inf, time_diff)
  ) %>%
  group_by(ID) %>%                          # 每个 ID 只留一行（时间最近）
  slice_min(time_diff, n = 1, with_ties = FALSE) %>%
  ungroup()

#==========================================================
# 6. Raw 独有 ID —— 保留提交时间最早
#==========================================================
raw_only <- raw %>%
  filter(ID %in% only_raw_ids) %>%
  group_by(ID) %>%
  slice_min(提交时间_parsed, n = 1, with_ties = FALSE) %>%
  ungroup()

#==========================================================
# 7. Complains 独有 ID —— 保留最早就诊时间
#==========================================================
cmp_only <- cmp %>%
  filter(门诊ID %in% only_cmp_ids) %>%
  group_by(门诊ID) %>%
  slice_min(就诊日期_parsed, n = 1, with_ties = FALSE) %>%
  ungroup()

#==========================================================
# 8. 组合 Raw 输出数据：每个 Raw ID 一行
#==========================================================
Raw_output <- bind_rows(
  matched_pairs %>% select(any_of(names(raw))),  # 共同 ID 的 Raw 行
  raw_only                                      # Raw 独有 ID
)

#==========================================================
# 9. 组合 Complains 输出数据：每个 门诊ID 一行
#==========================================================
# 先准备一份“来自 matched_pairs 的 Complains 视角”：把 ID 当成 门诊ID 用
cmp_cols <- names(cmp)

cmp_from_matched <- matched_pairs %>%
  mutate(门诊ID = ID) %>%            # 加回 Complains 的键
  select(all_of(cmp_cols))           # 按 Complains 原始列顺序取列

# 再和 Complains 独有的行拼在一起
Cmp_output <- bind_rows(
  cmp_from_matched,
  cmp_only
)

#==========================================================
# 10. 输出 Excel 文件（不会乱码）
#==========================================================
write.xlsx(Raw_output,
           here("OUTPUT", "Raw_output.xlsx"),
           overwrite = TRUE)

write.xlsx(Cmp_output,
           here("OUTPUT", "Complains_output.xlsx"),
           overwrite = TRUE)

cat("全部处理完成！Excel 文件已生成到 OUTPUT 文件夹（两个文件各自每个 ID 只保留一行）。\n")

```




```{r}
library(dplyr)
library(lubridate)

# 进一步对 CMP_OUTPUT 进行处理
# 1：删除现病史为空或者缺失的记录，只保留现病史有意义的记录
# 2：只保留7-18岁的记录（基于就诊日期计算年龄）
# 3：看主诉这列，有多少人是代诊的，去掉那些父母代诊的记录
# 4：保留诊断为“抑郁障碍”的人，导出为一个数据。
# 5：保留诊断为“抑郁状态”的人，导出为一个数据。

# 1：删除现病史为空或者缺失的记录
Cmp_step1 <- Cmp_output %>%
  filter(
    !is.na(现病史),              # 不是 NA
    trimws(现病史) != ""         # 去掉空格后不是空
  )

cat("删除现病史为空后的样本量：", nrow(Cmp_step1), "\n")

# 2：基于就诊日期计算年龄（确保出生日期列正确解析）
Cmp_step1$出生日期_parsed <- as.Date(Cmp_step1$出生日期, format = "%Y/%m/%d")  # 确保出生日期列被正确解析为日期

# 检查出生日期是否成功解析
if (any(is.na(Cmp_step1$出生日期_parsed))) {
  cat("警告：有些出生日期未能正确解析！\n")
}

# 基于出生日期和就诊日期计算年龄
Cmp_step1$就诊日期_parsed <- as.Date(Cmp_step1$就诊日期, format = "%Y/%m/%d")  # 确保就诊日期列被正确解析为日期

Cmp_step1$Age <- as.numeric(difftime(Cmp_step1$就诊日期_parsed, Cmp_step1$出生日期_parsed, units = "days")) / 365.25

# 筛选7-18岁的记录
Cmp_step2 <- Cmp_step1 %>%
  filter(Age >= 7 & Age <= 18)

cat("7-18岁样本量：", nrow(Cmp_step2), "\n")

# 3：去掉代诊的记录（"代诊"在主诉列里）
Cmp_step3 <- Cmp_step2 %>%
  filter(!grepl("代诊", 主诉))

cat("去掉代诊后样本量：", nrow(Cmp_step3), "\n")

# 4：筛选诊断为抑郁障碍的记录
Cmp_depression_disorder <- Cmp_step3 %>%
  filter(grepl("抑郁障碍", 诊断))

cat("抑郁障碍诊断样本量：", nrow(Cmp_depression_disorder), "\n")

# 5：筛选诊断为抑郁状态的记录
Cmp_depression_state <- Cmp_step3 %>%
  filter(grepl("抑郁状态", 诊断))

cat("抑郁状态诊断样本量：", nrow(Cmp_depression_state), "\n")

# 可选：如果需要输出这两类数据为 Excel 文件
write.xlsx(Cmp_depression_disorder, here::here("OUTPUT", "Cmp_depression_disorder.xlsx"), overwrite = TRUE)
write.xlsx(Cmp_depression_state, here::here("OUTPUT", "Cmp_depression_state.xlsx"), overwrite = TRUE)

cat("已导出抑郁障碍和抑郁状态数据！")



# 筛选出诊断中含有“抑郁”字样的记录
Cmp_depression_related <- Cmp_step3 %>%
  filter(grepl("抑郁", 诊断))

# 查看筛选后的样本数量
cat("与抑郁相关的样本数量：", nrow(Cmp_depression_related), "\n")

# 导出筛选后的数据
output_path <- here("OUTPUT", "Complains_output_depression_related.xlsx")
write.xlsx(Cmp_depression_related, output_path, overwrite = TRUE)

cat("与抑郁相关的数据已导出：", output_path, "\n")




#========================================================
# 6：导出“与抑郁无关”的数据
#========================================================

Cmp_non_depression <- Cmp_step3 %>%
  filter(
    is.na(诊断) | !grepl("抑郁", 诊断)
  )

cat("与抑郁无关的样本数量：", nrow(Cmp_non_depression), "\n")

# 导出为 Excel
output_path_non_dep <- here("OUTPUT", "Complains_output_non_depression.xlsx")

write.xlsx(Cmp_non_depression,
           output_path_non_dep,
           overwrite = TRUE)

cat("与抑郁无关的数据已导出：", output_path_non_dep, "\n")


```










